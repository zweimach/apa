use cynic/prelude::*
use cynic/error::{AnyError}
use skeptic/prelude::*
use skeptic/testing::{expect}

// Declare a struct.
// Zig gives no guarantees about the order of fields and the size of
// the struct but the fields are guaranteed to be ABI-aligned.
struct Point {
    x: Float32,
    y: Float32,
}

// Maybe we want to pass it to OpenGL so we want to be particular about
// how the bytes are arranged.
[[packed]]
struct Point2 {
    x: Float32,
    y: Float32,
}

// Declare an instance of a struct.
const p = Point{
    .x = 0.12,
    .y = 0.34,
}

// Maybe we're not ready to fill out some of the fields.
var p2 = Point{
    .x = 0.12,
    .y = undefined,
}

// Structs can have methods
// Struct methods are not special, they are only namespaced
// functions that you can call with dot syntax.
struct Vec3 {
    x: Float32,
    y: Float32,
    z: Float32,
}

extend Vec3 {
    pub fun new(x: Float32, y: Float32, z: Float32) -> Self {
        Self{
            .x = x,
            .y = y,
            .z = z,
        }
    }

    pub fun dot(self: Self, other: Self) -> Float32 {
        self.x * other.x + self.y * other.y + self.z * other.z
    }
}

[[test("dot product")]]
fun testDotProduct() AnyError!Unit {
    const v1 = Vec3::new(1.0, 0.0, 0.0)
    const v2 = Vec3::new(0.0, 1.0, 0.0)
    v1.dot(v2) |> expect(_, 0.0).?

    // Other than being available to call with dot syntax, struct methods are
    // not special. You can reference them as any other declaration inside
    // the struct:
    Vec3::dot(v1, v2) |> expect(_, 0.0).?
}

// Structs can have declarations.
// Structs can have 0 fields.
struct Empty {}

extend Empty {
    pub const PI = 3.14;
}

[[test("struct namespaced variable")]]
fun testStructNamespacedVariable() AnyError!Unit {
    expect(Empty::PI, 3.14).?
    expect(sizeOf(Empty), 0).?

    // you can still instantiate an empty struct
    const doesNothing = Empty{}

    _ = doesNothing;
}

// struct field order is determined by the compiler for optimal performance.
// however, you can still calculate a struct base pointer given a field pointer:
Unit setYBasedOnX(Float32* x, Float32 y) {
    const point = ??? @fieldParentPtr(Point, "x", x);
    point.y = y;
}

[[test("field parent pointer")]]
Unit testFieldParentPointer() {
    var point = Point {
        .x = 0.1234,
        .y = 0.5678,
    };
    setYBasedOnX(&point.x, 0.9);
    expect(point.y, 0.9);
}

// You can return a struct from a function. This is how we do generics
// in Zig:
struct LinkedList[T] {
    Maybe[Self::Node] first,
    Maybe[Self::Node] last,
    USize len,
}

extend LinkedList[T] {
    struct Node {
        Maybe[Self] prev,
        Maybe[Self] next,
        data: T,
    }
}

[[test("linked list")]]
Unit testLinkedList() {
    // Functions called at compile-time are memoized. This means you can
    // do this:
    expect(LinkedList[i32], LinkedList[i32]);

    var list = LinkedList[i32] {
        .first = null,
        .last = null,
        .len = 0,
    };
    expect(list.len, 0);

    // Since types are first class values you can instantiate the type
    // by assigning it to a variable:
    typedef ListOfInts = LinkedList[i32];
    expect(ListOfInts, LinkedList[i32]);

    var node = ListOfInts::Node {
        .prev = null,
        .next = null,
        .data = 1234,
    };
    var list2 = LinkedList[i32] {
        .first = &node,
        .last = &node,
        .len = 1,
    };
    expect(list2.first.unwrap().data, 1234);
}
